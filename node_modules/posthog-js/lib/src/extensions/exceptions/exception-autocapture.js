var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { window } from '../../utils';
import { errorToProperties, unhandledRejectionToProperties } from './error-conversion';
import { isPrimitive } from './type-checking';
var EXCEPTION_INGESTION_ENDPOINT = '/e/';
var ExceptionObserver = /** @class */ (function () {
    function ExceptionObserver(instance) {
        this.originalOnErrorHandler = undefined;
        this.originalOnUnhandledRejectionHandler = undefined;
        this.errorsToIgnore = [];
        this.instance = instance;
    }
    ExceptionObserver.prototype.debugLog = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.instance.config.debug) {
            console.log.apply(console, __spreadArray(['PostHog.js [PostHog.ExceptionObserver]'], __read(args), false));
        }
    };
    ExceptionObserver.prototype.startCapturing = function () {
        var _a;
        if (!this.isEnabled() || ((_a = window.onerror) === null || _a === void 0 ? void 0 : _a.__POSTHOG_INSTRUMENTED__)) {
            return;
        }
        try {
            this.originalOnErrorHandler = window.onerror;
            window.onerror = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                this.captureException(args);
                if (this.originalOnErrorHandler) {
                    // eslint-disable-next-line prefer-rest-params
                    return this.originalOnErrorHandler.apply(this, args);
                }
                return false;
            }.bind(this);
            window.onerror.__POSTHOG_INSTRUMENTED__ = true;
            this.originalOnUnhandledRejectionHandler = window.onunhandledrejection;
            window.onunhandledrejection = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var errorProperties = unhandledRejectionToProperties(args);
                this.sendExceptionEvent(errorProperties);
                if (this.originalOnUnhandledRejectionHandler) {
                    // eslint-disable-next-line prefer-rest-params
                    return this.originalOnUnhandledRejectionHandler.apply(window, args);
                }
                return true;
            }.bind(this);
            window.onunhandledrejection.__POSTHOG_INSTRUMENTED__ = true;
        }
        catch (e) {
            console.error('PostHog failed to start exception autocapture', e);
            this.stopCapturing();
        }
    };
    ExceptionObserver.prototype.stopCapturing = function () {
        var _a, _b;
        if (this.originalOnErrorHandler !== undefined) {
            window.onerror = this.originalOnErrorHandler;
            this.originalOnErrorHandler = null;
        }
        (_a = window.onerror) === null || _a === void 0 ? true : delete _a.__POSTHOG_INSTRUMENTED__;
        if (this.originalOnUnhandledRejectionHandler !== undefined) {
            window.onunhandledrejection = this.originalOnUnhandledRejectionHandler;
            this.originalOnUnhandledRejectionHandler = null;
        }
        (_b = window.onunhandledrejection) === null || _b === void 0 ? true : delete _b.__POSTHOG_INSTRUMENTED__;
    };
    ExceptionObserver.prototype.isCapturing = function () {
        var _a;
        return !!((_a = window.onerror) === null || _a === void 0 ? void 0 : _a.__POSTHOG_INSTRUMENTED__);
    };
    ExceptionObserver.prototype.isEnabled = function () {
        var _a;
        return (_a = this.remoteEnabled) !== null && _a !== void 0 ? _a : false;
    };
    ExceptionObserver.prototype.afterDecideResponse = function (response) {
        var autocaptureExceptionsResponse = response.autocaptureExceptions;
        this.remoteEnabled = !!autocaptureExceptionsResponse || false;
        if (!isPrimitive(autocaptureExceptionsResponse) &&
            'errors_to_ignore' in autocaptureExceptionsResponse &&
            Array.isArray(autocaptureExceptionsResponse.errors_to_ignore)) {
            var dropRules = autocaptureExceptionsResponse.errors_to_ignore;
            this.errorsToIgnore = dropRules.map(function (rule) {
                return new RegExp(rule);
            });
        }
        if (this.isEnabled()) {
            this.startCapturing();
            this.debugLog('Remote config for exception autocapture is enabled, starting', autocaptureExceptionsResponse);
        }
        else {
            this.debugLog('Remote config for exception autocapture is disabled, not starting', autocaptureExceptionsResponse);
        }
    };
    ExceptionObserver.prototype.captureException = function (args, properties) {
        var errorProperties = errorToProperties(args);
        if (this.errorsToIgnore.some(function (regex) { return regex.test(errorProperties.$exception_message || ''); })) {
            this.debugLog('Ignoring exception based on remote config', errorProperties);
            return;
        }
        var propertiesToSend = __assign(__assign({}, properties), errorProperties);
        var posthogHost = this.instance.config.ui_host || this.instance.config.api_host;
        errorProperties.$exception_personURL = posthogHost + '/person/' + this.instance.get_distinct_id();
        this.sendExceptionEvent(propertiesToSend);
    };
    /**
     * :TRICKY: Make sure we batch these requests
     */
    ExceptionObserver.prototype.sendExceptionEvent = function (properties) {
        this.instance.capture('$exception', properties, {
            transport: 'XHR',
            method: 'POST',
            endpoint: EXCEPTION_INGESTION_ENDPOINT,
            _noTruncate: true,
            _batchKey: 'exceptionEvent',
        });
    };
    return ExceptionObserver;
}());
export { ExceptionObserver };
//# sourceMappingURL=exception-autocapture.js.map