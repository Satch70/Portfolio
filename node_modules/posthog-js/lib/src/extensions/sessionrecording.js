var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE, SESSION_RECORDING_ENABLED_SERVER_SIDE, SESSION_RECORDING_RECORDER_VERSION_SERVER_SIDE, } from '../constants';
import { ensureMaxMessageSize, FULL_SNAPSHOT_EVENT_TYPE, INCREMENTAL_SNAPSHOT_EVENT_TYPE, META_EVENT_TYPE, MutationRateLimiter, truncateLargeConsoleLogs, } from './sessionrecording-utils';
import { EventType } from '@rrweb/types';
import Config from '../config';
import { logger, loadScript, _timestamp } from '../utils';
var BASE_ENDPOINT = '/s/';
export var RECORDING_IDLE_ACTIVITY_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
export var RECORDING_MAX_EVENT_SIZE = 1024 * 1024 * 0.9; // ~1mb (with some wiggle room)
export var RECORDING_BUFFER_TIMEOUT = 2000; // 2 seconds
export var SESSION_RECORDING_BATCH_KEY = 'recordings';
// NOTE: Importing this type is problematic as we can't safely bundle it to a TS definition so, instead we redefine.
// import type { record } from 'rrweb2/typings'
// import type { recordOptions } from 'rrweb/typings/types'
// Copied from rrweb typings to avoid import
var IncrementalSource;
(function (IncrementalSource) {
    IncrementalSource[IncrementalSource["Mutation"] = 0] = "Mutation";
    IncrementalSource[IncrementalSource["MouseMove"] = 1] = "MouseMove";
    IncrementalSource[IncrementalSource["MouseInteraction"] = 2] = "MouseInteraction";
    IncrementalSource[IncrementalSource["Scroll"] = 3] = "Scroll";
    IncrementalSource[IncrementalSource["ViewportResize"] = 4] = "ViewportResize";
    IncrementalSource[IncrementalSource["Input"] = 5] = "Input";
    IncrementalSource[IncrementalSource["TouchMove"] = 6] = "TouchMove";
    IncrementalSource[IncrementalSource["MediaInteraction"] = 7] = "MediaInteraction";
    IncrementalSource[IncrementalSource["StyleSheetRule"] = 8] = "StyleSheetRule";
    IncrementalSource[IncrementalSource["CanvasMutation"] = 9] = "CanvasMutation";
    IncrementalSource[IncrementalSource["Font"] = 10] = "Font";
    IncrementalSource[IncrementalSource["Log"] = 11] = "Log";
    IncrementalSource[IncrementalSource["Drag"] = 12] = "Drag";
    IncrementalSource[IncrementalSource["StyleDeclaration"] = 13] = "StyleDeclaration";
    IncrementalSource[IncrementalSource["Selection"] = 14] = "Selection";
    IncrementalSource[IncrementalSource["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
})(IncrementalSource || (IncrementalSource = {}));
var ACTIVE_SOURCES = [
    IncrementalSource.MouseMove,
    IncrementalSource.MouseInteraction,
    IncrementalSource.Scroll,
    IncrementalSource.ViewportResize,
    IncrementalSource.Input,
    IncrementalSource.TouchMove,
    IncrementalSource.MediaInteraction,
    IncrementalSource.Drag,
];
var SessionRecording = /** @class */ (function () {
    function SessionRecording(instance) {
        var _this = this;
        this.lastActivityTimestamp = Date.now();
        this.isIdle = false;
        this.instance = instance;
        this.captureStarted = false;
        this.snapshots = [];
        this.emit = false; // Controls whether data is sent to the server or not
        this.endpoint = BASE_ENDPOINT;
        this.stopRrweb = undefined;
        this.windowId = null;
        this.sessionId = null;
        this.receivedDecide = false;
        window.addEventListener('beforeunload', function () {
            _this._flushBuffer();
        });
    }
    SessionRecording.prototype.getSessionManager = function () {
        if (!this.instance.sessionManager) {
            logger.error('Session recording started without valid sessionManager');
            return;
        }
        return this.instance.sessionManager;
    };
    SessionRecording.prototype.startRecordingIfEnabled = function () {
        if (this.isRecordingEnabled()) {
            this.startCaptureAndTrySendingQueuedSnapshots();
        }
        else {
            this.stopRecording();
        }
    };
    SessionRecording.prototype.started = function () {
        return this.captureStarted;
    };
    SessionRecording.prototype.stopRecording = function () {
        if (this.captureStarted && this.stopRrweb) {
            this.stopRrweb();
            this.stopRrweb = undefined;
            this.captureStarted = false;
        }
    };
    SessionRecording.prototype.isRecordingEnabled = function () {
        var enabled_server_side = !!this.instance.get_property(SESSION_RECORDING_ENABLED_SERVER_SIDE);
        var enabled_client_side = !this.instance.config.disable_session_recording;
        return enabled_server_side && enabled_client_side;
    };
    SessionRecording.prototype.isConsoleLogCaptureEnabled = function () {
        var enabled_server_side = !!this.instance.get_property(CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE);
        var enabled_client_side = this.instance.config.enable_recording_console_log;
        return enabled_client_side !== null && enabled_client_side !== void 0 ? enabled_client_side : enabled_server_side;
    };
    SessionRecording.prototype.getRecordingVersion = function () {
        var _a;
        var recordingVersion_server_side = this.instance.get_property(SESSION_RECORDING_RECORDER_VERSION_SERVER_SIDE);
        var recordingVersion_client_side = (_a = this.instance.config.session_recording) === null || _a === void 0 ? void 0 : _a.recorderVersion;
        return recordingVersion_client_side || recordingVersion_server_side || 'v1';
    };
    SessionRecording.prototype.afterDecideResponse = function (response) {
        var _a;
        var _b, _c, _d, _e, _f;
        this.receivedDecide = true;
        if (this.instance.persistence) {
            this.instance.persistence.register((_a = {},
                _a[SESSION_RECORDING_ENABLED_SERVER_SIDE] = !!response['sessionRecording'],
                _a[CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE] = (_b = response.sessionRecording) === null || _b === void 0 ? void 0 : _b.consoleLogRecordingEnabled,
                _a[SESSION_RECORDING_RECORDER_VERSION_SERVER_SIDE] = (_c = response.sessionRecording) === null || _c === void 0 ? void 0 : _c.recorderVersion,
                _a));
        }
        if ((_d = response.sessionRecording) === null || _d === void 0 ? void 0 : _d.endpoint) {
            this.endpoint = (_e = response.sessionRecording) === null || _e === void 0 ? void 0 : _e.endpoint;
        }
        if ((_f = response.sessionRecording) === null || _f === void 0 ? void 0 : _f.recorderVersion) {
            this.recorderVersion = response.sessionRecording.recorderVersion;
        }
        this.startRecordingIfEnabled();
    };
    SessionRecording.prototype.log = function (message, level) {
        var _a;
        if (level === void 0) { level = 'log'; }
        (_a = this.instance.sessionRecording) === null || _a === void 0 ? void 0 : _a.onRRwebEmit({
            type: 6,
            data: {
                plugin: 'rrweb/console@1',
                payload: {
                    level: level,
                    trace: [],
                    // Even though it is a string we stringify it as thats what rrweb expects
                    payload: [JSON.stringify(message)],
                },
            },
            timestamp: _timestamp(),
        });
    };
    SessionRecording.prototype.startCaptureAndTrySendingQueuedSnapshots = function () {
        var _this = this;
        // Only submit data after we've received a decide response to account for
        // changing endpoints and the feature being disabled on the server side.
        if (this.receivedDecide) {
            this.emit = true;
            this.snapshots.forEach(function (properties) { return _this._captureSnapshotBuffered(properties); });
        }
        this._startCapture();
    };
    SessionRecording.prototype._startCapture = function () {
        var _this = this;
        var sessionManager = this.getSessionManager();
        if (!sessionManager) {
            return;
        }
        if (typeof Object.assign === 'undefined') {
            // According to the rrweb docs, rrweb is not supported on IE11 and below:
            // "rrweb does not support IE11 and below because it uses the MutationObserver API which was supported by these browsers."
            // https://github.com/rrweb-io/rrweb/blob/master/guide.md#compatibility-note
            //
            // However, MutationObserver does exist on IE11, it just doesn't work well and does not detect all changes.
            // Instead, when we load "recorder.js", the first JS error is about "Object.assign" being undefined.
            // Thus instead of MutationObserver, we look for this function and block recording if it's undefined.
            return;
        }
        // We do not switch recorder versions midway through a recording.
        if (this.captureStarted || this.instance.config.disable_session_recording) {
            return;
        }
        this.captureStarted = true;
        // We want to ensure the sessionManager is reset if necessary on load of the recorder
        sessionManager.checkAndGetSessionAndWindowId();
        var recorderJS = this.getRecordingVersion() === 'v2' ? 'recorder-v2.js' : 'recorder.js';
        // If recorder.js is already loaded (if array.full.js snippet is used or posthog-js/dist/recorder is
        // imported) or matches the requested recorder version, don't load script. Otherwise, remotely import
        // recorder.js from cdn since it hasn't been loaded.
        if (this.instance.__loaded_recorder_version !== this.getRecordingVersion()) {
            loadScript(this.instance.config.api_host + "/static/".concat(recorderJS, "?v=").concat(Config.LIB_VERSION), function (err) {
                if (err) {
                    return logger.error("Could not load ".concat(recorderJS), err);
                }
                _this._onScriptLoaded();
            });
        }
        else {
            this._onScriptLoaded();
        }
    };
    SessionRecording.prototype._isInteractiveEvent = function (event) {
        var _a;
        return event.type === INCREMENTAL_SNAPSHOT_EVENT_TYPE && ACTIVE_SOURCES.indexOf((_a = event.data) === null || _a === void 0 ? void 0 : _a.source) !== -1;
    };
    SessionRecording.prototype._updateWindowAndSessionIds = function (event) {
        var sessionManager = this.getSessionManager();
        if (!sessionManager) {
            return;
        }
        // Some recording events are triggered by non-user events (e.g. "X minutes ago" text updating on the screen).
        // We don't want to extend the session or trigger a new session in these cases. These events are designated by event
        // type -> incremental update, and source -> mutation.
        var isUserInteraction = this._isInteractiveEvent(event);
        if (!isUserInteraction && !this.isIdle) {
            // We check if the lastActivityTimestamp is old enough to go idle
            if (event.timestamp - this.lastActivityTimestamp > RECORDING_IDLE_ACTIVITY_TIMEOUT_MS) {
                this.isIdle = true;
            }
        }
        if (isUserInteraction) {
            this.lastActivityTimestamp = event.timestamp;
            if (this.isIdle) {
                // Remove the idle state if set and trigger a full snapshot as we will have ingored previous mutations
                this.isIdle = false;
                this._tryTakeFullSnapshot();
            }
        }
        if (this.isIdle) {
            return;
        }
        // We only want to extend the session if it is an interactive event.
        var _a = sessionManager.checkAndGetSessionAndWindowId(!isUserInteraction, event.timestamp), windowId = _a.windowId, sessionId = _a.sessionId;
        if ([FULL_SNAPSHOT_EVENT_TYPE, META_EVENT_TYPE].indexOf(event.type) === -1 &&
            (this.windowId !== windowId || this.sessionId !== sessionId)) {
            this._tryTakeFullSnapshot();
        }
        this.windowId = windowId;
        this.sessionId = sessionId;
    };
    SessionRecording.prototype._tryTakeFullSnapshot = function () {
        var _a;
        if (!this.captureStarted) {
            return false;
        }
        try {
            (_a = this.rrwebRecord) === null || _a === void 0 ? void 0 : _a.takeFullSnapshot();
            return true;
        }
        catch (e) {
            // Sometimes a race can occur where the recorder is not fully started yet, so we can't take a full snapshot.
            logger.error('Error taking full snapshot.', e);
            return false;
        }
    };
    SessionRecording.prototype._onScriptLoaded = function () {
        var e_1, _a;
        var _this = this;
        var _b;
        // rrweb config info: https://github.com/rrweb-io/rrweb/blob/7d5d0033258d6c29599fb08412202d9a2c7b9413/src/record/index.ts#L28
        var sessionRecordingOptions = {
            // select set of rrweb config options we expose to our users
            // see https://github.com/rrweb-io/rrweb/blob/master/guide.md
            blockClass: 'ph-no-capture',
            blockSelector: undefined,
            ignoreClass: 'ph-ignore-input',
            maskTextClass: 'ph-mask',
            maskTextSelector: undefined,
            maskTextFn: undefined,
            maskAllInputs: true,
            maskInputOptions: {},
            maskInputFn: undefined,
            slimDOMOptions: {},
            collectFonts: false,
            inlineStylesheet: true,
            recordCrossOriginIframes: false,
        };
        // We switched from loading all of rrweb to just the record part, but
        // keep backwards compatibility if someone hasn't upgraded PostHog
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.rrwebRecord = window.rrweb ? window.rrweb.record : window.rrwebRecord;
        // only allows user to set our 'allowlisted' options
        var userSessionRecordingOptions = this.instance.config.session_recording;
        try {
            for (var _c = __values(Object.entries(userSessionRecordingOptions || {})), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
                if (key in sessionRecordingOptions) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    sessionRecordingOptions[key] = value;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!this.rrwebRecord) {
            logger.error('onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.');
            return;
        }
        this.mutationRateLimiter =
            (_b = this.mutationRateLimiter) !== null && _b !== void 0 ? _b : new MutationRateLimiter(this.rrwebRecord, {
                onBlockedNode: function (id, node) {
                    var message = "Too many mutations on node '".concat(id, "'. Rate limiting. This could be due to SVG animations or something similar");
                    logger.log(message, {
                        node: node,
                    });
                    _this.log('[PostHog Recorder] ' + message, 'warn');
                },
            });
        this.stopRrweb = this.rrwebRecord(__assign({ emit: function (event) {
                _this.onRRwebEmit(event);
            }, plugins: window.rrwebConsoleRecord && this.isConsoleLogCaptureEnabled()
                ? [window.rrwebConsoleRecord.getRecordConsolePlugin()]
                : [] }, sessionRecordingOptions));
        // :TRICKY: rrweb does not capture navigation within SPA-s, so hook into our $pageview events to get access to all events.
        //   Dropping the initial event is fine (it's always captured by rrweb).
        this.instance._addCaptureHook(function (eventName) {
            var _a;
            // If anything could go wrong here it has the potential to block the main loop so we catch all errors.
            try {
                if (eventName === '$pageview') {
                    var href = _this._maskUrl(window.location.href);
                    if (!href) {
                        return;
                    }
                    (_a = _this.rrwebRecord) === null || _a === void 0 ? void 0 : _a.addCustomEvent('$pageview', { href: href });
                }
            }
            catch (e) {
                logger.error('Could not add $pageview to rrweb session', e);
            }
        });
        // We reset the last activity timestamp, resetting the idle timer
        this.lastActivityTimestamp = Date.now();
        this.isIdle = false;
    };
    SessionRecording.prototype.onRRwebEmit = function (rawEvent) {
        if (!rawEvent || typeof rawEvent !== 'object') {
            return;
        }
        if (rawEvent.type === EventType.Meta) {
            var href = this._maskUrl(rawEvent.data.href);
            if (!href) {
                return;
            }
            rawEvent.data.href = href;
        }
        var throttledEvent = this.mutationRateLimiter
            ? this.mutationRateLimiter.throttleMutations(rawEvent)
            : rawEvent;
        if (!throttledEvent) {
            return;
        }
        var _a = ensureMaxMessageSize(truncateLargeConsoleLogs(throttledEvent)), event = _a.event, size = _a.size;
        this._updateWindowAndSessionIds(event);
        if (this.isIdle) {
            // When in an idle state we keep recording, but don't capture the events
            return;
        }
        var properties = {
            $snapshot_bytes: size,
            $snapshot_data: event,
            $session_id: this.sessionId,
            $window_id: this.windowId,
        };
        if (this.emit) {
            this._captureSnapshotBuffered(properties);
        }
        else {
            this.snapshots.push(properties);
        }
    };
    SessionRecording.prototype._maskUrl = function (url) {
        var userSessionRecordingOptions = this.instance.config.session_recording;
        if (userSessionRecordingOptions.maskNetworkRequestFn) {
            var networkRequest = {
                url: url,
            };
            networkRequest = userSessionRecordingOptions.maskNetworkRequestFn(networkRequest);
            return networkRequest === null || networkRequest === void 0 ? void 0 : networkRequest.url;
        }
        return url;
    };
    SessionRecording.prototype._flushBuffer = function () {
        if (this.flushBufferTimer) {
            clearTimeout(this.flushBufferTimer);
            this.flushBufferTimer = undefined;
        }
        if (this.buffer && this.buffer.data.length !== 0) {
            this._captureSnapshot({
                $snapshot_bytes: this.buffer.size,
                $snapshot_data: this.buffer.data,
                $session_id: this.buffer.sessionId,
                $window_id: this.buffer.windowId,
            });
        }
        this.buffer = undefined;
        return {
            size: 0,
            data: [],
            sessionId: this.sessionId,
            windowId: this.windowId,
        };
    };
    SessionRecording.prototype._captureSnapshotBuffered = function (properties) {
        var _this = this;
        var _a;
        var additionalBytes = 2 + (((_a = this.buffer) === null || _a === void 0 ? void 0 : _a.data.length) || 0); // 2 bytes for the array brackets and 1 byte for each comma
        if (!this.buffer ||
            this.buffer.size + properties.$snapshot_bytes + additionalBytes > RECORDING_MAX_EVENT_SIZE ||
            this.buffer.sessionId !== this.sessionId) {
            this.buffer = this._flushBuffer();
        }
        this.buffer.size += properties.$snapshot_bytes;
        this.buffer.data.push(properties.$snapshot_data);
        if (!this.flushBufferTimer) {
            this.flushBufferTimer = setTimeout(function () {
                _this._flushBuffer();
            }, RECORDING_BUFFER_TIMEOUT);
        }
    };
    SessionRecording.prototype._captureSnapshot = function (properties) {
        // :TRICKY: Make sure we batch these requests, use a custom endpoint and don't truncate the strings.
        this.instance.capture('$snapshot', properties, {
            transport: 'XHR',
            method: 'POST',
            endpoint: this.endpoint,
            _noTruncate: true,
            _batchKey: SESSION_RECORDING_BATCH_KEY,
            _metrics: {
                rrweb_full_snapshot: properties.$snapshot_data.type === FULL_SNAPSHOT_EVENT_TYPE,
            },
        });
    };
    return SessionRecording;
}());
export { SessionRecording };
//# sourceMappingURL=sessionrecording.js.map